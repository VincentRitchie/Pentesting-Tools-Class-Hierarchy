# Base class for all pentesting tools
class PentestingTool:
    def __init__(self, name, version, category):
        # Initialize the tool with a name, version, and category
        self.name = name
        self.version = version
        self.category = category

    def run(self):
        # Abstract method for running the tool
        # This should be overridden by subclasses
        raise NotImplementedError("This method should be overridden by subclasses")

    def __str__(self):
        # String representation of the tool
        return f"{self.name} (v{self.version}) - {self.category} Tool"

# Subclass for Scanner tools
class Scanner(PentestingTool):
    def __init__(self, name, version):
        # Initialize a Scanner with a name and version
        # Category is set to "Scanner"
        super().__init__(name, version, "Scanner")

    def run(self, target):
        # Implement the run method for Scanner
        # This method will perform scanning on the specified target
        print(f"Running {self.name} scanner on {target}")
        import auto_scanning_thread #Imported an auto scanning sign for real life simulation 

# Subclass for Brute Forcer tools
class BruteForcer(PentestingTool):
    def __init__(self, name, version):
        # Initialize a BruteForcer with a name and version
        # Category is set to "Brute Forcer"
        super().__init__(name, version, "Brute Forcer")

    def run(self, target, wordlist):
        # Implement the run method for Brute Forcer
        # This method will perform a brute force attack on the target using the specified wordlist
        print(f"Running {self.name} brute force attack on {target} using wordlist {wordlist}...")

# Subclass for Exploiter tools
class Exploiter(PentestingTool):
    def __init__(self, name, version):
        # Initialize an Exploiter with a name and version
        # Category is set to "Exploiter"
        super().__init__(name, version, "Exploiter")

    def run(self, target, exploit):
        # Implement the run method for Exploiter
        # This method will exploit the target using the specified exploit
        print(f"Exploiting {target} with {self.name} using exploit {exploit}...")

# Function to create a tool based on user input
def create_tool():
    # Ask the user to input the type of tool
    tool_type = input("Enter the type of tool (Scanner, BruteForcer, Exploiter): ")

    # Ask the user to input the name of the tool
    name = input("Enter the name of the tool: ")

    # Ask the user to input the version of the tool
    version = input("Enter the version of the tool: ")

    # Create the tool based on the user's input
    if tool_type.lower() == "scanner":
        return Scanner(name, version)
    elif tool_type.lower() == "bruteforcer":
        return BruteForcer(name, version)
    elif tool_type.lower() == "exploiter":
        return Exploiter(name, version)
    else:
        print("Invalid tool type entered.")
        return None

# Main function to run the tools
def main():
    # Create a tool using user input
    tool = create_tool()

    # If the tool was created successfully, ask for additional details and run it
    if tool:
        # Ask the user to input the target IP address
        target = input("Enter the target IP address: ")

        # Check the type of tool and ask for additional details accordingly
        if isinstance(tool, BruteForcer):
            wordlist = input("Enter the path to the wordlist: ")
            tool.run(target, wordlist)
        elif isinstance(tool, Exploiter):
            exploit = input("Enter the name of the exploit: ")
            tool.run(target, exploit)
        else:
            tool.run(target)

# Run the main function
if __name__ == "__main__":
    main()
